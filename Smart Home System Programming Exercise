
#Creational Design Patterns
#1)Singleton Pattern: Logger Configuration
class Logger:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.log_file = "app.log"
        return cls._instance

    def log(self, message):
        with open(self.log_file, "a") as f:
            f.write(f"{message}\n")

# Usage
logger1 = Logger()
logger2 = Logger()
print(logger1 is logger2)  # True (same instance)

logger1.log("Error 404")
logger2.log("User logged in")
# Both write to "app.log"

#2)Factory Method Pattern: Vehicle Manufacturing
from abc import ABC, abstractmethod

class Vehicle(ABC):
    @abstractmethod
    def drive(self):
        pass

class Car(Vehicle):
    def drive(self):
        print("Driving a car")

class Truck(Vehicle):
    def drive(self):
        print("Driving a truck")

class VehicleFactory:
    @staticmethod
    def create_vehicle(vehicle_type):
        if vehicle_type == "car":
            return Car()
        elif vehicle_type == "truck":
            return Truck()
        return None

# Usage
factory = VehicleFactory()
car = factory.create_vehicle("car")
truck = factory.create_vehicle("truck")
car.drive()    # Driving a car
truck.drive()  # Driving a truck

#Structural Design Patterns
#1)Adapter Pattern: Legacy System Integration
class LegacyReporter:
    def generate_report(self, data):
        return f"Legacy Report: {data}"

class ModernAnalytics:
    def process_data(self, data):
        return f"Modern Analytics: {data}"

class ReporterAdapter:
    def __init__(self, legacy_reporter):
        self.legacy_reporter = legacy_reporter

    def process_data(self, data):
        legacy_format = self.legacy_reporter.generate_report(data)
        return f"Adapted: {legacy_format}"

# Usage
legacy = LegacyReporter()
adapter = ReporterAdapter(legacy)
modern = ModernAnalytics()

print(adapter.process_data("Sales Q1"))  # Adapted: Legacy Report: Sales Q1
print(modern.process_data("Sales Q1"))   # Modern Analytics: Sales Q1

#2)Decorator Pattern: Coffee Customization
class Coffee:
    def cost(self):
        return 5
    def description(self):
        return "Simple Coffee"

class MilkDecorator:
    def __init__(self, coffee):
        self._coffee = coffee

    def cost(self):
        return self._coffee.cost() + 1

    def description(self):
        return self._coffee.description() + ", Milk"

class SugarDecorator:
    def __init__(self, coffee):
        self._coffee = coffee

    def cost(self):
        return self._coffee.cost() + 0.5

    def description(self):
        return self._coffee.description() + ", Sugar"

# Usage
coffee = Coffee()
print(f"{coffee.description()}: ${coffee.cost()}")  # Simple Coffee: $5

coffee_with_milk = MilkDecorator(coffee)
print(f"{coffee_with_milk.description()}: ${coffee_with_milk.cost()}")  # Simple Coffee, Milk: $6

coffee_with_milk_sugar = SugarDecorator(coffee_with_milk)
print(f"{coffee_with_milk_sugar.description()}: ${coffee_with_milk_sugar.cost()}")  # Simple Coffee, Milk, Sugar: $6.5




#EXERCISE:2 Smart Home System Programming Exercise
from abc import ABC, abstractmethod
from datetime import datetime, time
import re
import json
from typing import Dict, List, Any, Optional

# ==================== DEVICE CLASSES ====================

class Device(ABC):
    """Abstract base class for all smart devices"""
    def __init__(self, device_id: int, device_type: str):
        self._device_id = device_id
        self._device_type = device_type
        self._status = "off"
    
    @property
    def device_id(self) -> int:
        return self._device_id
    
    @property
    def device_type(self) -> str:
        return self._device_type
    
    @property
    def status(self) -> str:
        return self._status
    
    @abstractmethod
    def turn_on(self) -> None:
        pass
    
    @abstractmethod
    def turn_off(self) -> None:
        pass
    
    @abstractmethod
    def get_status(self) -> str:
        pass
    
    @abstractmethod
    def execute_action(self, action: str) -> None:
        """Execute a device-specific action"""
        pass


class Light(Device):
    """Smart light device"""
    def __init__(self, device_id: int):
        super().__init__(device_id, "light")
        self._brightness = 100  # Default brightness
    
    def turn_on(self) -> None:
        self._status = "on"
        print(f"Light {self._device_id} turned on")
    
    def turn_off(self) -> None:
        self._status = "off"
        print(f"Light {self._device_id} turned off")
    
    def get_status(self) -> str:
        return f"Light {self._device_id} is {self._status}"
    
    def set_brightness(self, level: int) -> None:
        self._brightness = max(0, min(100, level))
        print(f"Light {self._device_id} brightness set to {self._brightness}%")
    
    def execute_action(self, action: str) -> None:
        if action == "Turn On":
            self.turn_on()
        elif action == "Turn Off":
            self.turn_off()
        elif action.startswith("Set Brightness"):
            match = re.search(r"Set Brightness to (\d+)", action)
            if match:
                brightness = int(match.group(1))
                self.set_brightness(brightness)


class Thermostat(Device):
    """Smart thermostat device"""
    def __init__(self, device_id: int, temperature: int = 70):
        super().__init__(device_id, "thermostat")
        self._temperature = temperature
        self._target_temp = temperature
    
    def turn_on(self) -> None:
        self._status = "on"
        print(f"Thermostat {self._device_id} turned on")
    
    def turn_off(self) -> None:
        self._status = "off"
        print(f"Thermostat {self._device_id} turned off")
    
    def set_temperature(self, temp: int) -> None:
        self._target_temp = temp
        print(f"Thermostat {self._device_id} target temperature set to {temp}°F")
    
    def get_status(self) -> str:
        return f"Thermostat {self._device_id} is {self._status} (Current: {self._temperature}°F, Target: {self._target_temp}°F)"
    
    def execute_action(self, action: str) -> None:
        if action == "Turn On":
            self.turn_on()
        elif action == "Turn Off":
            self.turn_off()
        elif action.startswith("Set Temperature"):
            match = re.search(r"Set Temperature to (\d+)", action)
            if match:
                temp = int(match.group(1))
                self.set_temperature(temp)


class DoorLock(Device):
    """Smart door lock device"""
    def __init__(self, device_id: int):
        super().__init__(device_id, "door")
        self._status = "locked"
    
    def turn_on(self) -> None:
        self.lock()
    
    def turn_off(self) -> None:
        self.unlock()
    
    def lock(self) -> None:
        self._status = "locked"
        print(f"Door {self._device_id} locked")
    
    def unlock(self) -> None:
        self._status = "unlocked"
        print(f"Door {self._device_id} unlocked")
    
    def get_status(self) -> str:
        return f"Door {self._device_id} is {self._status}"
    
    def execute_action(self, action: str) -> None:
        if action == "Lock":
            self.lock()
        elif action == "Unlock":
            self.unlock()


# ==================== DEVICE FACTORY (CREATIONAL PATTERN) ====================

class DeviceFactory:
    """Factory for creating device instances (Factory Method Pattern)"""
    @staticmethod
    def create_device(device_id: int, device_type: str, **kwargs) -> Device:
        if device_type == "light":
            return Light(device_id)
        elif device_type == "thermostat":
            temperature = kwargs.get("temperature", 70)
            return Thermostat(device_id, temperature)
        elif device_type == "door":
            return DoorLock(device_id)
        else:
            raise ValueError(f"Unknown device type: {device_type}")


# ==================== DEVICE PROXY (STRUCTURAL PATTERN) ====================

class DeviceProxy:
    """Proxy for controlling access to devices (Proxy Pattern)"""
    def __init__(self, real_device: Device):
        self._real_device = real_device
        self._access_log = []
    
    @property
    def device_id(self) -> int:
        return self._real_device.device_id
    
    @property
    def device_type(self) -> str:
        return self._real_device.device_type
    
    def turn_on(self) -> None:
        self._log_access("turn_on")
        self._real_device.turn_on()
    
    def turn_off(self) -> None:
        self._log_access("turn_off")
        self._real_device.turn_off()
    
    def get_status(self) -> str:
        self._log_access("get_status")
        return self._real_device.get_status()
    
    def execute_action(self, action: str) -> None:
        self._log_access(f"execute_action: {action}")
        self._real_device.execute_action(action)
    
    def _log_access(self, action: str) -> None:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"{timestamp} - Device {self._real_device.device_id} ({self._real_device.device_type}): {action}"
        self._access_log.append(log_entry)
        print(f"[ACCESS LOG] {log_entry}")
    
    def get_access_log(self) -> List[str]:
        return self._access_log


# ==================== OBSERVER PATTERN IMPLEMENTATION ====================

class Observer(ABC):
    """Abstract observer interface"""
    @abstractmethod
    def update(self, subject: 'Subject') -> None:
        pass


class Subject(ABC):
    """Abstract subject interface"""
    @abstractmethod
    def attach(self, observer: Observer) -> None:
        pass
    
    @abstractmethod
    def detach(self, observer: Observer) -> None:
        pass
    
    @abstractmethod
    def notify(self) -> None:
        pass


class Trigger(Observer):
    """Represents an automated trigger that responds to system changes"""
    def __init__(self, condition: str, action: str):
        self._condition = condition
        self._action = action
    
    @property
    def condition(self) -> str:
        return self._condition
    
    @property
    def action(self) -> str:
        return self._action
    
    def update(self, subject: 'SmartHomeHub') -> None:
        """Check if trigger condition is met and execute action if true"""
        if self._evaluate_condition(subject):
            print(f"[TRIGGER] Condition met: {self._condition}")
            subject.execute_command(self._action)
    
    def _evaluate_condition(self, hub: 'SmartHomeHub') -> bool:
        """Evaluate the trigger condition based on current device states"""
        # Parse condition (e.g., "temperature > 75")
        match = re.match(r"(\w+)\s*([><=!]+)\s*(\d+)", self._condition)
        if not match:
            return False
        
        device_type, operator, value = match.groups()
        value = int(value)
        
        # Find devices of the specified type
        devices = [d for d in hub.devices.values() if d.device_type == device_type.lower()]
        if not devices:
            return False
        
        # Check condition for each device of the specified type
        for device in devices:
            if device.device_type == "thermostat":
                current_temp = getattr(device, "_temperature", 0)
                if self._compare(current_temp, operator, value):
                    return True
        
        return False
    
    def _compare(self, value1: int, operator: str, value2: int) -> bool:
        """Compare two values based on the operator"""
        if operator == ">":
            return value1 > value2
        elif operator == "<":
            return value1 < value2
        elif operator == ">=":
            return value1 >= value2
        elif operator == "<=":
            return value1 <= value2
        elif operator == "==":
            return value1 == value2
        elif operator == "!=":
            return value1 != value2
        return False


# ==================== SMART HOME HUB (SUBJECT) ====================

class SmartHomeHub(Subject):
    """Central hub that manages all smart devices and automation"""
    def __init__(self):
        self._devices: Dict[int, DeviceProxy] = {}
        self._observers: List[Observer] = []
        self._scheduled_tasks: List[Dict[str, Any]] = []
        self._triggers: List[Trigger] = []
    
    @property
    def devices(self) -> Dict[int, DeviceProxy]:
        return self._devices
    
    @property
    def scheduled_tasks(self) -> List[Dict[str, Any]]:
        return self._scheduled_tasks
    
    @property
    def triggers(self) -> List[Trigger]:
        return self._triggers
    
    def add_device(self, device: Device) -> None:
        """Add a device to the smart home system"""
        proxy = DeviceProxy(device)
        self._devices[device.device_id] = proxy
        print(f"Added {device.device_type} device with ID {device.device_id}")
    
    def remove_device(self, device_id: int) -> None:
        """Remove a device from the smart home system"""
        if device_id in self._devices:
            del self._devices[device_id]
            print(f"Removed device with ID {device_id}")
        else:
            print(f"Device with ID {device_id} not found")
    
    def attach(self, observer: Observer) -> None:
        """Attach an observer to the hub"""
        if observer not in self._observers:
            self._observers.append(observer)
            if isinstance(observer, Trigger):
                self._triggers.append(observer)
    
    def detach(self, observer: Observer) -> None:
        """Detach an observer from the hub"""
        if observer in self._observers:
            self._observers.remove(observer)
            if isinstance(observer, Trigger) and observer in self._triggers:
                self._triggers.remove(observer)
    
    def notify(self) -> None:
        """Notify all observers about a state change"""
        for observer in self._observers:
            observer.update(self)
    
    def execute_command(self, command: str) -> None:
        """Execute a command on a device"""
        # Parse command (e.g., "turnOn(1)")
        match = re.match(r"(\w+)\((\d+)(?:,\s*(.+))?\)", command)
        if not match:
            print(f"Invalid command format: {command}")
            return
        
        action, device_id, args = match.groups()
        device_id = int(device_id)
        
        if device_id not in self._devices:
            print(f"Device with ID {device_id} not found")
            return
        
        device = self._devices[device_id]
        
        # Execute the action
        if action == "turnOn":
            device.turn_on()
        elif action == "turnOff":
            device.turn_off()
        elif action == "setSchedule":
            if args:
                time_str, cmd = args.split(", ")
                self.set_schedule(device_id, time_str.strip('"'), cmd.strip('"'))
        elif action == "addTrigger":
            if args:
                condition, action = args.split(", ")
                self.add_trigger(condition.strip('"'), action.strip('"'))
        else:
            print(f"Unknown action: {action}")
            return
        
        # Notify observers after state change
        self.notify()
    
    def set_schedule(self, device_id: int, time_str: str, command: str) -> None:
        """Schedule a command for a device at a specific time"""
        try:
            # Parse time (e.g., "06:00")
            hour, minute = map(int, time_str.split(":"))
            schedule_time = time(hour, minute)
            
            self._scheduled_tasks.append({
                "device_id": device_id,
                "time": schedule_time,
                "command": command
            })
            print(f"Scheduled task: Device {device_id} at {time_str} -> {command}")
        except ValueError:
            print(f"Invalid time format: {time_str}. Use HH:MM format.")
    
    def add_trigger(self, condition: str, action: str) -> None:
        """Add an automated trigger based on a condition"""
        trigger = Trigger(condition, action)
        self.attach(trigger)
        print(f"Added trigger: If {condition} then {action}")
    
    def run_scheduled_tasks(self) -> None:
        """Execute scheduled tasks that are due"""
        now = datetime.now().time()
        tasks_to_remove = []
        
        for task in self._scheduled_tasks:
            if now >= task["time"]:
                device_id = task["device_id"]
                command = task["command"]
                
                if device_id in self._devices:
                    device = self._devices[device_id]
                    device.execute_action(command)
                    print(f"Executed scheduled task: {command} for device {device_id}")
                
                tasks_to_remove.append(task)
        
        # Remove executed tasks
        for task in tasks_to_remove:
            self._scheduled_tasks.remove(task)
    
    def get_status_report(self) -> str:
        """Generate a status report of all devices"""
        status_list = [device.get_status() for device in self._devices.values()]
        return ". ".join(status_list) + "."
    
    def get_scheduled_tasks_report(self) -> str:
        """Generate a report of all scheduled tasks"""
        if not self._scheduled_tasks:
            return "No scheduled tasks."
        
        task_reports = []
        for task in self._scheduled_tasks:
            time_str = task["time"].strftime("%H:%M")
            task_reports.append(
                f"{{device: {task['device_id']}, time: \"{time_str}\", command: \"{task['command']}\"}}"
            )
        
        return f"[{', '.join(task_reports)}]"
    
    def get_triggers_report(self) -> str:
        """Generate a report of all triggers"""
        if not self._triggers:
            return "No automated triggers."
        
        trigger_reports = []
        for trigger in self._triggers:
            trigger_reports.append(
                f"{{condition: \"{trigger.condition}\", action: \"{trigger.action}\"}}"
            )
        
        return f"[{', '.join(trigger_reports)}]"


# ==================== SMART HOME SYSTEM ====================

class SmartHomeSystem:
    """Main system that initializes and manages the smart home"""
    def __init__(self, devices_data: List[Dict[str, Any]]):
        self.hub = SmartHomeHub()
        self.factory = DeviceFactory()
        self._initialize_devices(devices_data)
    
    def _initialize_devices(self, devices_data: List[Dict[str, Any]]) -> None:
        """Initialize all devices from the provided data"""
        for device_data in devices_data:
            device_id = device_data["id"]
            device_type = device_data["type"]
            
            # Create device using factory
            if device_type == "thermostat":
                device = self.factory.create_device(
                    device_id=device_id,
                    device_type=device_type,
                    temperature=device_data.get("temperature", 70)
                )
            else:
                device = self.factory.create_device(
                    device_id=device_id,
                    device_type=device_type
                )
            
            # Set initial status if provided
            if "status" in device_data:
                if device_data["status"] == "on" or (device_type == "door" and device_data["status"] == "unlocked"):
                    device.turn_on()
                else:
                    device.turn_off()
            
            # Add device to hub
            self.hub.add_device(device)
    
    def process_commands(self, commands: List[str]) -> None:
        """Process a list of commands"""
        for command in commands:
            print(f"\nProcessing command: {command}")
            self.hub.execute_command(command)
    
    def run_scheduled_tasks(self) -> None:
        """Run all scheduled tasks that are due"""
        self.hub.run_scheduled_tasks()
    
    def generate_reports(self) -> Dict[str, str]:
        """Generate system reports"""
        return {
            "Status Report": self.hub.get_status_report(),
            "Scheduled Tasks": self.hub.get_scheduled_tasks_report(),
            "Automated Triggers": self.hub.get_triggers_report()
        }


# ==================== DEMONSTRATION ====================

def main():
    # Initialize the Smart Home System with devices
    devices_data = [
        {"id": 1, "type": "light", "status": "off"},
        {"id": 2, "type": "thermostat", "temperature": 70},
        {"id": 3, "type": "door", "status": "locked"}
    ]
    
    commands = [
        'turnOn(1)',
        'setSchedule(2, "06:00", "Turn On")',
        'addTrigger("temperature > 75", "turnOff(1)")'
    ]
    
    print("=== Smart Home System Initialization ===")
    smart_home = SmartHomeSystem(devices_data)
    
    print("\n=== Initial Status Report ===")
    reports = smart_home.generate_reports()
    for report_type, report_content in reports.items():
        print(f"{report_type}: {report_content}")
    
    print("\n=== Processing Commands ===")
    smart_home.process_commands(commands)
    
    print("\n=== Status After Commands ===")
    reports = smart_home.generate_reports()
    for report_type, report_content in reports.items():
        print(f"{report_type}: {report_content}")
    
    print("\n=== Simulating Scheduled Task Execution ===")
    # For demonstration, we'll manually run scheduled tasks
    smart_home.run_scheduled_tasks()
    
    print("\n=== Simulating Trigger Condition ===")
    # Simulate temperature change to trigger the automation
    thermostat = smart_home.hub.devices[2]
    thermostat._real_device._temperature = 76  # Simulate temperature rising above 75
    smart_home.hub.notify()  # Manually trigger notification to check conditions
    
    print("\n=== Final Status Report ===")
    reports = smart_home.generate_reports()
    for report_type, report_content in reports.items():
        print(f"{report_type}: {report_content}")


if __name__ == "__main__":
    main()
